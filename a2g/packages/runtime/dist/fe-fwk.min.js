const t={ADD:"add",REMOVE:"remove",MOVE:"move",NOOP:"noop"};function e(t){return t.filter((t=>null!=t))}class n{#t=[];#e=[];#n;constructor(t,e){this.#t=[...t],this.#e=t.map(((t,e)=>e)),this.#n=e}get length(){return this.#t.length}isRemoval(t,e){if(t>=this.length)return!1;const n=this.#t[t];return-1===e.findIndex((t=>this.#n(n,t)))}removeItem(e){const n={op:t.REMOVE,index:e,item:this.#t[e]};return this.#t.splice(e,1),this.#e.splice(e,1),n}isNoop(t,e){if(t>=this.length)return!1;const n=this.#t[t],r=e[t];return this.#n(n,r)}originalIndexAt(t){return this.#e[t]}noopItem(e){return{op:t.NOOP,originalIndex:this.originalIndexAt(e),index:e,item:this.#t[e]}}isAddition(t,e){return-1===this.findIndexFrom(t,e)}findIndexFrom(t,e){for(let n=e;n<this.length;n++)if(this.#n(t,this.#t[n]))return n;return-1}addItem(e,n){const r={op:t.ADD,index:n,item:e};return this.#t.splice(n,0,e),this.#e.splice(n,0,-1),r}moveItem(e,n){const r=this.findIndexFrom(e,n),s={op:t.MOVE,originalIndex:this.originalIndexAt(r),from:r,index:n,item:this.#t[r]},[o]=this.#t.splice(r,1);this.#t.splice(n,0,o);const[i]=this.#e.splice(r,1);return this.#e.splice(n,0,i),s}removeItemsAfter(t){const e=[];for(;this.length>t;)e.push(this.removeItem(t));return e}}const r={TEXT:"text",ELEMENT:"element",FRAGMENT:"fragment",COMPONENT:"component"};function s(t,n={},s=[]){const o="string"==typeof t?r.ELEMENT:r.COMPONENT;return{tag:t,props:n,children:i(e(s)),type:o}}function o(t){return{type:r.TEXT,value:t}}function i(t){return t.map((t=>"string"==typeof t?o(t):t))}function c(t){return{type:r.FRAGMENT,children:i(e(t))}}function a(t){if(null==t.children)return[];const e=[];for(const n of t.children)n.type===r.FRAGMENT?e.push(...a(n)):e.push(n);return e}function l(t,e){const{class:n,style:r,...s}=e;n&&function(t,e){t.className="","string"==typeof e&&(t.className=e);Array.isArray(e)&&t.classList.add(...e)}(t,n),r&&Object.entries(r).forEach((([e,n])=>{u(t,e,n)}));for(const[e,n]of Object.entries(s))f(t,e,n)}function u(t,e,n){t.style[e]=n}function h(t,e){t.style[e]=null}function f(t,e,n){null==n?d(t,e):e.startsWith("data-")?t.setAttribute(e,n):t[e]=n}function d(t,e){t[e]=null,t.removeAttribute(e)}function p(t,e,n,r=null){function s(){r?e.apply(r,arguments):e(...arguments)}return n.addEventListener(t,s),s}function m(t){const{on:e={},...n}=t.props;return delete n.key,{props:n,events:e}}function E(t,e,n,s=null){switch(t.type){case r.TEXT:!function(t,e,n){const{value:r}=t,s=document.createTextNode(r);t.el=s,y(s,e,n)}(t,e,n);break;case r.ELEMENT:!function(t,e,n,r){const{tag:s,children:o}=t,i=document.createElement(s);(function(t,e,n){const{props:r,events:s}=m(e);e.listeners=function(t={},e,n=null){const r={};return Object.entries(t).forEach((([t,s])=>{const o=p(t,s,e,n);r[t]=o})),r}(s,t,n),l(t,r)})(i,t,r),t.el=i,o.forEach((t=>E(t,i,null,r))),y(i,e,n)}(t,e,n,s);break;case r.FRAGMENT:!function(t,e,n,r){const{children:s}=t;t.el=e,s.forEach(((t,s)=>E(t,e,n?n+s:null,r)))}(t,e,n,s);break;case r.COMPONENT:!function(t,e,n,r){const s=t.tag,{props:o,events:i}=m(t),c=new s(o,i,r);c.mount(e,n),t.component=c,t.el=c.firstElement}(t,e,n,s);break;default:throw new Error(`Can't mount DOM of type: ${t.type}`)}}function y(t,e,n){if(null==n)return void e.append(t);if(n<0)throw new Error(`Index must be a positive integer, got ${n}`);const r=e.childNodes;n>=r.length?e.append(t):e.insertBefore(t,r[n])}function v(t){const{type:e}=t;switch(e){case r.TEXT:!function(t){const{el:e}=t;e.remove()}(t);break;case r.ELEMENT:!function(t){const{el:e,children:n,listeners:r}=t;e.remove(),n.forEach(v),r&&(!function(t={},e){Object.entries(t).forEach((([t,n])=>{e.removeEventListener(t,n)}))}(r,e),delete t.listeners)}(t);break;case r.FRAGMENT:!function(t){const{children:e}=t;e.forEach(v)}(t);break;case r.COMPONENT:t.component.unmount();break;default:throw new Error(`Can't destroy DOM of type: ${e}`)}delete t.el}function g(t,e={}){let n=null,r=!1,o=null;return{mount(i){if(r)throw new Error("The application is already mounted");n=i,o=s(t,e),E(o,n),r=!0},unmount(){if(!r)throw new Error("The application is not mounted");v(o),n=null,r=!1,o=null}}}function O(t,e){if(t.type!==e.type)return!1;if(t.type===r.ELEMENT){const{tag:n,props:{key:r}}=t,{tag:s,props:{key:o}}=e;return n===s&&r===o}if(t.type===r.COMPONENT){const{tag:n,props:{key:r}}=t,{tag:s,props:{key:o}}=e;return n===s&&r===o}return!0}function b(t,e){const n=Object.keys(t),r=Object.keys(e);return{added:r.filter((e=>!(e in t))),removed:n.filter((t=>!(t in e))),updated:r.filter((n=>n in t&&t[n]!==e[n]))}}function N(t){return function(t){return""!==t}(t.trim())}function M(e,s,o,i=null){if(!O(e,s)){const t=function(t,e){const n=Array.from(t.childNodes).indexOf(e);if(n<0)return null;return n}(o,e.el);return v(e),E(s,o,t,i),s}switch(s.el=e.el,s.type){case r.TEXT:return function(t,e){const n=t.el,{value:r}=t,{value:s}=e;r!==s&&(n.nodeValue=s)}(e,s),s;case r.ELEMENT:!function(t,e,n){const r=t.el,{class:s,style:o,on:i,...c}=t.props,{class:a,style:l,on:m,...E}=e.props,{listeners:y}=t;(function(t,e,n){const{added:r,removed:s,updated:o}=b(e,n);for(const e of s)d(t,e);for(const e of r.concat(o))f(t,e,n[e])})(r,c,E),function(t,e,n){const r=w(e),s=w(n),{added:o,removed:i}=(c=r,a=s,{added:a.filter((t=>!c.includes(t))),removed:c.filter((t=>!a.includes(t)))});var c,a;i.length>0&&t.classList.remove(...i);o.length>0&&t.classList.add(...o)}(r,s,a),function(t,e={},n={}){const{added:r,removed:s,updated:o}=b(e,n);for(const e of s)h(t,e);for(const e of r.concat(o))u(t,e,n[e])}(r,o,l),e.listeners=function(t,e={},n={},r={},s){const{removed:o,added:i,updated:c}=b(n,r);for(const n of o.concat(c))t.removeEventListener(n,e[n]);const a={};for(const e of i.concat(c)){const n=p(e,r[e],t,s);a[e]=n}return a}(r,y,i,m,n)}(e,s,i);break;case r.COMPONENT:!function(t,e){const{component:n}=t,{props:r}=e;n.updateProps(r),e.component=n,e.el=n.firstElement}(e,s)}return function(e,r,s){const o=a(e),i=a(r),c=e.el,l=function(t,e,r=((t,e)=>t===e)){const s=[],o=new n(t,r);for(let t=0;t<e.length;t++){if(o.isRemoval(t,e)){s.push(o.removeItem(t));continue}if(o.isNoop(t,e)){s.push(o.noopItem(t));continue}const n=e[t];o.isAddition(n,t)?s.push(o.addItem(n,t)):s.push(o.moveItem(n,t))}return s.push(...o.removeItemsAfter(e.length)),s}(o,i,O);for(const e of l){const{originalIndex:n,index:r,item:a}=e,l=s?.offset??0;switch(e.op){case t.ADD:E(a,c,r+l,s);break;case t.REMOVE:v(a);break;case t.MOVE:{const t=o[n],e=i[r],a=t.el,u=c.childNodes[r+l];c.insertBefore(a,u),M(t,e,c,s);break}case t.NOOP:M(o[n],i[r],c,s)}}}(e,s,i),s}function w(t=""){return Array.isArray(t)?t.filter(N):t.split(/(\s+)/).filter(N)}var T,I=(T=function t(e,n){if(e===n)return!0;if(e&&n&&"object"==typeof e&&"object"==typeof n){if(e.constructor!==n.constructor)return!1;var r,s,o;if(Array.isArray(e)){if((r=e.length)!=n.length)return!1;for(s=r;0!=s--;)if(!t(e[s],n[s]))return!1;return!0}if(e.constructor===RegExp)return e.source===n.source&&e.flags===n.flags;if(e.valueOf!==Object.prototype.valueOf)return e.valueOf()===n.valueOf();if(e.toString!==Object.prototype.toString)return e.toString()===n.toString();if((r=(o=Object.keys(e)).length)!==Object.keys(n).length)return!1;for(s=r;0!=s--;)if(!Object.prototype.hasOwnProperty.call(n,o[s]))return!1;for(s=r;0!=s--;){var i=o[s];if(!t(e[i],n[i]))return!1}return!0}return e!=e&&n!=n},T&&T.__esModule&&Object.prototype.hasOwnProperty.call(T,"default")?T.default:T);class A{#r=new Map;#s=[];subscribe(t,e){this.#r.has(t)||this.#r.set(t,[]);const n=this.#r.get(t);return n.includes(e)?()=>{}:(n.push(e),()=>{const t=n.indexOf(e);n.splice(t,1)})}afterEveryCommand(t){return this.#s.push(t),()=>{const e=this.#s.indexOf(t);this.#s.splice(e,1)}}dispatch(t,e){this.#r.has(t)?this.#r.get(t).forEach((t=>t(e))):console.warn(`No handlers for command: ${t}`),this.#s.forEach((t=>t()))}}function x({render:t,state:e,...n}){class s{#o=!1;#i=null;#c=null;#a=null;#l=null;#u=new A;#h=[];#f(){this.#h=Object.entries(this.#a).map((([t,e])=>this.#d(t,e)))}#d(t,e){return this.#u.subscribe(t,(t=>{this.#l?e.call(this.#l,t):e(t)}))}constructor(t={},n={},r=null){this.props=t,this.state=e?e(t):{},this.#a=n,this.#l=r}updateProps(t){const e={...this.props,...t};I(this.props,e)||(this.props=e,this.#p())}updateState(t){this.state={...this.state,...t},this.#p()}get elements(){return null==this.#i?[]:this.#i.type===r.FRAGMENT?a(this.#i).flatMap((t=>t.type===r.COMPONENT?t.component.elements:[t.el])):[this.#i.el]}get firstElement(){return this.elements[0]}get offset(){return this.#i.type===r.FRAGMENT?Array.from(this.#c.children).indexOf(this.firstElement):0}render(){return t.call(this)}mount(t,e=null){if(this.#o)throw new Error("Component is already mounted");this.#i=this.render(),E(this.#i,t,e,this),this.#f(),this.#c=t,this.#o=!0}unmount(){if(!this.#o)throw new Error("Component is not mounted");v(this.#i),this.#h.forEach((t=>t())),this.#i=null,this.#c=null,this.#o=!1,this.#h=[]}#p(){if(!this.#o)throw new Error("Component is not mounted");const t=this.render();this.#i=M(this.#i,t,this.#c,this)}emit(t,e){this.#u.dispatch(t,e)}}for(const t in n){if(o=s,i=t,Object.prototype.hasOwnProperty.call(o,i))throw new Error(`Method "${t}()" already exists in the component.`);s.prototype[t]=n[t]}var o,i;return s}export{r as DOM_TYPES,g as createApp,x as defineComponent,s as h,c as hFragment,o as hString};
