const t={ADD:"add",REMOVE:"remove",MOVE:"move",NOOP:"noop"};function e(t){return t.filter((t=>null!=t))}class n{#t=[];#e=[];#n;constructor(t,e){this.#t=[...t],this.#e=t.map(((t,e)=>e)),this.#n=e}get length(){return this.#t.length}isRemoval(t,e){if(t>=this.length)return!1;const n=this.#t[t];return-1===e.findIndex((t=>this.#n(n,t)))}removeItem(e){const n={op:t.REMOVE,index:e,item:this.#t[e]};return this.#t.splice(e,1),this.#e.splice(e,1),n}isNoop(t,e){if(t>=this.length)return!1;const n=this.#t[t],r=e[t];return this.#n(n,r)}originalIndexAt(t){return this.#e[t]}noopItem(e){return{op:t.NOOP,originalIndex:this.originalIndexAt(e),index:e,item:this.#t[e]}}isAddition(t,e){return-1===this.findIndexFrom(t,e)}findIndexFrom(t,e){for(let n=e;n<this.length;n++)if(this.#n(t,this.#t[n]))return n;return-1}addItem(e,n){const r={op:t.ADD,index:n,item:e};return this.#t.splice(n,0,e),this.#e.splice(n,0,-1),r}moveItem(e,n){const r=this.findIndexFrom(e,n),o={op:t.MOVE,originalIndex:this.originalIndexAt(r),from:r,index:n,item:this.#t[r]},[s]=this.#t.splice(r,1);this.#t.splice(n,0,s);const[i]=this.#e.splice(r,1);return this.#e.splice(n,0,i),o}removeItemsAfter(t){const e=[];for(;this.length>t;)e.push(this.removeItem(t));return e}}const r={TEXT:"text",ELEMENT:"element",FRAGMENT:"fragment",COMPONENT:"component"};function o(t,n={},o=[]){const s="string"==typeof t?r.ELEMENT:r.COMPONENT;return{tag:t,props:n,children:i(e(o)),type:s}}function s(t){return{type:r.TEXT,value:t}}function i(t){return t.map((t=>"string"==typeof t?s(t):t))}function c(t){return{type:r.FRAGMENT,children:i(e(t))}}function u(t){if(null==t.children)return[];const e=[];for(const n of t.children)n.type===r.FRAGMENT?e.push(...u(n)):e.push(n);return e}function l(t,e){const{class:n,style:r,...o}=e;n&&function(t,e){t.className="","string"==typeof e&&(t.className=e);Array.isArray(e)&&t.classList.add(...e)}(t,n),r&&Object.entries(r).forEach((([e,n])=>{a(t,e,n)}));for(const[e,n]of Object.entries(o))f(t,e,n)}function a(t,e,n){t.style[e]=n}function h(t,e){t.style[e]=null}function f(t,e,n){null==n?d(t,e):e.startsWith("data-")?t.setAttribute(e,n):t[e]=n}function d(t,e){t[e]=null,t.removeAttribute(e)}function p(t,e,n,r=null){function o(){r?e.apply(r,arguments):e(...arguments)}return n.addEventListener(t,o),o}let m=!1;const E=[];function y(t){E.push(t),v()}function v(){m||(m=!0,queueMicrotask(g))}function g(){for(;E.length>0;){const t=E.shift()();Promise.resolve(t).then((()=>{}),(t=>{console.error(`[scheduler]: ${t}`)}))}m=!1}function O(){return v(),new Promise((t=>setTimeout(t)))}function b(t){const{on:e={},...n}=t.props;return delete n.key,{props:n,events:e}}function M(t,e,n,o=null){switch(t.type){case r.TEXT:!function(t,e,n){const{value:r}=t,o=document.createTextNode(r);t.el=o,N(o,e,n)}(t,e,n);break;case r.ELEMENT:!function(t,e,n,r){const{tag:o,children:s}=t,i=document.createElement(o);(function(t,e,n){const{props:r,events:o}=b(e);e.listeners=function(t={},e,n=null){const r={};return Object.entries(t).forEach((([t,o])=>{const s=p(t,o,e,n);r[t]=s})),r}(o,t,n),l(t,r)})(i,t,r),t.el=i,s.forEach((t=>M(t,i,null,r))),N(i,e,n)}(t,e,n,o);break;case r.FRAGMENT:!function(t,e,n,r){const{children:o}=t;t.el=e,o.forEach(((t,o)=>M(t,e,n?n+o:null,r)))}(t,e,n,o);break;case r.COMPONENT:!function(t,e,n,r){const o=t.tag,{props:s,events:i}=b(t),c=new o(s,i,r);c.mount(e,n),t.component=c,t.el=c.firstElement}(t,e,n,o),y((()=>t.component.onMounted()));break;default:throw new Error(`Can't mount DOM of type: ${t.type}`)}}function N(t,e,n){if(null==n)return void e.append(t);if(n<0)throw new Error(`Index must be a positive integer, got ${n}`);const r=e.childNodes;n>=r.length?e.append(t):e.insertBefore(t,r[n])}function w(t){const{type:e}=t;switch(e){case r.TEXT:!function(t){const{el:e}=t;e.remove()}(t);break;case r.ELEMENT:!function(t){const{el:e,children:n,listeners:r}=t;e.remove(),n.forEach(w),r&&(!function(t={},e){Object.entries(t).forEach((([t,n])=>{e.removeEventListener(t,n)}))}(r,e),delete t.listeners)}(t);break;case r.FRAGMENT:!function(t){const{children:e}=t;e.forEach(w)}(t);break;case r.COMPONENT:t.component.unmount(),y((()=>t.component.onUnmounted()));break;default:throw new Error(`Can't destroy DOM of type: ${e}`)}delete t.el}function T(t,e={}){let n=null,r=!1,s=null;return{mount(i){if(r)throw new Error("The application is already mounted");n=i,s=o(t,e),M(s,n),r=!0},unmount(){if(!r)throw new Error("The application is not mounted");w(s),n=null,r=!1,s=null}}}function I(t,e){if(t.type!==e.type)return!1;if(t.type===r.ELEMENT){const{tag:n}=t,{tag:r}=e;return n===r}if(t.type===r.COMPONENT){const{tag:n,props:{key:r}}=t,{tag:o,props:{key:s}}=e;return n===o&&r===s}return!0}function A(t,e){const n=Object.keys(t),r=Object.keys(e);return{added:r.filter((e=>!(e in t))),removed:n.filter((t=>!(t in e))),updated:r.filter((n=>n in t&&t[n]!==e[n]))}}function k(t){return function(t){return""!==t}(t.trim())}function P(e,o,s,i=null){if(!I(e,o)){const t=function(t,e){const n=Array.from(t.childNodes).indexOf(e);if(n<0)return null;return n}(s,e.el);return w(e),M(o,s,t,i),o}switch(o.el=e.el,o.type){case r.TEXT:return function(t,e){const n=t.el,{value:r}=t,{value:o}=e;r!==o&&(n.nodeValue=o)}(e,o),o;case r.ELEMENT:!function(t,e,n){const r=t.el,{class:o,style:s,on:i,...c}=t.props,{class:u,style:l,on:m,...E}=e.props,{listeners:y}=t;(function(t,e,n){const{added:r,removed:o,updated:s}=A(e,n);for(const e of o)d(t,e);for(const e of r.concat(s))f(t,e,n[e])})(r,c,E),function(t,e,n){const r=C(e),o=C(n),{added:s,removed:i}=(c=r,u=o,{added:u.filter((t=>!c.includes(t))),removed:c.filter((t=>!u.includes(t)))});var c,u;i.length>0&&t.classList.remove(...i);s.length>0&&t.classList.add(...s)}(r,o,u),function(t,e={},n={}){const{added:r,removed:o,updated:s}=A(e,n);for(const e of o)h(t,e);for(const e of r.concat(s))a(t,e,n[e])}(r,s,l),e.listeners=function(t,e={},n={},r={},o){const{removed:s,added:i,updated:c}=A(n,r);for(const n of s.concat(c))t.removeEventListener(n,e[n]);const u={};for(const e of i.concat(c)){const n=p(e,r[e],t,o);u[e]=n}return u}(r,y,i,m,n)}(e,o,i);break;case r.COMPONENT:!function(t,e){const{component:n}=t,{props:r}=e;n.updateProps(r),e.component=n,e.el=n.firstElement}(e,o)}return function(e,r,o){const s=u(e),i=u(r),c=e.el,l=function(t,e,r=((t,e)=>t===e)){const o=[],s=new n(t,r);for(let t=0;t<e.length;t++){if(s.isRemoval(t,e)){o.push(s.removeItem(t));continue}if(s.isNoop(t,e)){o.push(s.noopItem(t));continue}const n=e[t];s.isAddition(n,t)?o.push(s.addItem(n,t)):o.push(s.moveItem(n,t))}return o.push(...s.removeItemsAfter(e.length)),o}(s,i,I);for(const e of l){const{originalIndex:n,index:r,item:u}=e,l=o?.offset??0;switch(e.op){case t.ADD:M(u,c,r+l,o);break;case t.REMOVE:w(u);break;case t.MOVE:{const t=s[n],e=i[r],u=t.el,a=c.childNodes[r+l];c.insertBefore(u,a),P(t,e,c,o);break}case t.NOOP:P(s[n],i[r],c,o)}}}(e,o,i),o}function C(t=""){return Array.isArray(t)?t.filter(k):t.split(/(\s+)/).filter(k)}x;var j=function(t){return t&&t.__esModule&&Object.prototype.hasOwnProperty.call(t,"default")?t.default:t}((function t(e,n){if(e===n)return!0;if(e&&n&&"object"==typeof e&&"object"==typeof n){if(e.constructor!==n.constructor)return!1;var r,o,s;if(Array.isArray(e)){if((r=e.length)!=n.length)return!1;for(o=r;0!=o--;)if(!t(e[o],n[o]))return!1;return!0}if(e.constructor===RegExp)return e.source===n.source&&e.flags===n.flags;if(e.valueOf!==Object.prototype.valueOf)return e.valueOf()===n.valueOf();if(e.toString!==Object.prototype.toString)return e.toString()===n.toString();if((r=(s=Object.keys(e)).length)!==Object.keys(n).length)return!1;for(o=r;0!=o--;)if(!Object.prototype.hasOwnProperty.call(n,s[o]))return!1;for(o=r;0!=o--;){var i=s[o];if(!t(e[i],n[i]))return!1}return!0}return e!=e&&n!=n}));class F{#r=new Map;#o=[];subscribe(t,e){this.#r.has(t)||this.#r.set(t,[]);const n=this.#r.get(t);return n.includes(e)?()=>{}:(n.push(e),()=>{const t=n.indexOf(e);n.splice(t,1)})}afterEveryCommand(t){return this.#o.push(t),()=>{const e=this.#o.indexOf(t);this.#o.splice(e,1)}}dispatch(t,e){this.#r.has(t)?this.#r.get(t).forEach((t=>t(e))):console.warn(`No handlers for command: ${t}`),this.#o.forEach((t=>t()))}}const R=()=>{};function H({render:t,state:e,onMounted:n=R,onUnmounted:o=R,...s}){class i{#s=!1;#i=null;#c=null;#u=null;#l=null;#a=new F;#h=[];constructor(t={},n={},r=null){this.props=t,this.state=e?e(t):{},this.#u=n,this.#l=r}onMounted(){return Promise.resolve(n.call(this))}onUnmounted(){return Promise.resolve(o.call(this))}#f(){this.#h=Object.entries(this.#u).map((([t,e])=>this.#d(t,e)))}#d(t,e){return this.#a.subscribe(t,(t=>{this.#l?e.call(this.#l,t):e(t)}))}updateProps(t){const e={...this.props,...t};j(this.props,e)||(this.props=e,this.#p())}updateState(t){this.state={...this.state,...t},this.#p()}get elements(){return null==this.#i?[]:this.#i.type===r.FRAGMENT?u(this.#i).flatMap((t=>t.type===r.COMPONENT?t.component.elements:[t.el])):[this.#i.el]}get firstElement(){return this.elements[0]}get offset(){return this.#i.type===r.FRAGMENT?Array.from(this.#c.children).indexOf(this.firstElement):0}render(){return t.call(this)}mount(t,e=null){if(this.#s)throw new Error("Component is already mounted");this.#i=this.render(),M(this.#i,t,e,this),this.#f(),this.#c=t,this.#s=!0}unmount(){if(!this.#s)throw new Error("Component is not mounted");w(this.#i),this.#h.forEach((t=>t())),this.#i=null,this.#c=null,this.#s=!1,this.#h=[]}#p(){if(!this.#s)throw new Error("Component is not mounted");const t=this.render();this.#i=P(this.#i,t,this.#c,this)}emit(t,e){this.#a.dispatch(t,e)}}for(const t in s){if(c=i,l=t,Object.prototype.hasOwnProperty.call(c,l))throw new Error(`Method "${t}()" already exists in the component.`);i.prototype[t]=s[t]}var c,l;return i}export{r as DOM_TYPES,T as createApp,H as defineComponent,o as h,c as hFragment,s as hString,O as nextTick};
